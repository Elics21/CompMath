def newton_multidim(F, J, x0, tol=1e-6, max_iter=100):
    """
    Находит решение системы нелинейных уравнений F(x) = 0
    с помощью многомерного метода Ньютона.

    Аргументы:
    F - вектор-функция, возвращающая значения уравнений
    J - функция, возвращающая матрицу Якоби
    x0 - начальное приближение
    tol - требуемая точность
    max_iter - максимальное число итераций
    """
    # Создаем копию начального приближения, чтобы не изменять исходные данные
    x = x0[:]

    # Запускаем цикл, который будет выполняться не более max_iter раз
    for i in range(max_iter):
        # Вычисляем значения левых частей уравнений F(x) и матрицу Якоби J(x)
        # в текущей точке x
        F_x = F(x)
        J_x = J(x)

        # Решаем систему линейных уравнений J(x)dx = -F(x)
        # с помощью метода Гаусса
        dx = gauss_solve(J_x, [-f for f in F_x])

        # Вычисляем новое приближение x_new = x + dx
        x_new = [x_i + dx_i for x_i, dx_i in zip(x, dx)]

        # Проверяем, достаточно ли близки значения левых частей уравнений к нулю
        # Если да, то решение найдено, и мы выводим его на экран
        if sum(f ** 2 for f in F_x) < tol ** 2:
            print(f"Решение найдено за {i+1} итераций:")
            return x_new

        # Обновляем текущее приближение x на новое x_new
        x = x_new

    # Если решение не найдено за max_iter итераций, выдаем ошибку
    raise ValueError("Метод не сошелся за максимальное число итераций")

def gauss_solve(A, b):
    """
    Решает систему линейных уравнений Ax = b
    методом Гаусса.
    """
    n = len(b)

    # Выполняем прямой ход метода Гаусса
    for i in range(n):
        # Находим строку с максимальным элементом в столбце i
        max_row = i
        for j in range(i + 1, n):
            if abs(A[j][i]) > abs(A[max_row][i]):
                max_row = j

        # Меняем местами строки i и max_row
        A[i], A[max_row] = A[max_row], A[i]
        b[i], b[max_row] = b[max_row], b[i]

        # Обнуляем элементы под главной диагональю
        for j in range(i + 1, n):
            factor = A[j][i] / A[i][i]
            for k in range(i, n):
                A[j][k] -= factor * A[i][k]
            b[j] -= factor * b[i]

    # Выполняем обратный ход метода Гаусса
    x = [0] * n
    for i in range(n - 1, -1, -1):
        s = b[i]
        for j in range(i + 1, n):
            s -= A[i][j] * x[j]
        x[i] = s / A[i][i]

    return x

def F(x):
    return [x[0]**2 + x[1]**2 - 4, x[0] - x[1] - 1]

def J(x):
    return [[2*x[0], 2*x[1]], [1, -1]]

x0 = [1, 1]
root = newton_multidim(F, J, x0)

print(f"Решение системы: {root}")